// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = require('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    nonAuthChars = ['/', '@', '?', '#'].concat(delims),
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always have a path component.
    pathedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && typeof(url) === 'object' && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (typeof url !== 'string') {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {
    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    // don't enforce full RFC correctness, just be unstupid about it.

    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the first @ sign, unless some non-auth character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    var atSign = rest.indexOf('@');
    if (atSign !== -1) {
      var auth = rest.slice(0, atSign);

      // there *may be* an auth
      var hasAuth = true;
      for (var i = 0, l = nonAuthChars.length; i < l; i++) {
        if (auth.indexOf(nonAuthChars[i]) !== -1) {
          // not a valid auth.  Something like http://foo.com/bar@baz/
          hasAuth = false;
          break;
        }
      }

      if (hasAuth) {
        // pluck off the auth portion.
        this.auth = decodeURIComponent(auth);
        rest = rest.substr(atSign + 1);
      }
    }

    var firstNonHost = -1;
    for (var i = 0, l = nonHostChars.length; i < l; i++) {
      var index = rest.indexOf(nonHostChars[i]);
      if (index !== -1 &&
          (firstNonHost < 0 || index < firstNonHost)) firstNonHost = index;
    }

    if (firstNonHost !== -1) {
      this.host = rest.substr(0, firstNonHost);
      rest = rest.substr(firstNonHost);
    } else {
      this.host = rest;
      rest = '';
    }

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[proto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (typeof(obj) === 'string') obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query && typeof this.query === 'object' &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (typeof relative === 'string') {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  Object.keys(this).forEach(function(k) {
    result[k] = this[k];
  }, this);

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    Object.keys(relative).forEach(function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      Object.keys(relative).forEach(function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (relative.search !== null && relative.search !== undefined) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (result.pathname !== null || result.search !== null) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (result.pathname !== null || result.search !== null) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};








































/*
 Copyright 2012 WiredPrairie.us

 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all copies or substantial portions
 of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
 TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 DEALINGS IN THE SOFTWARE.

 FYI: Nest is a registered trademark of Nest Labs

 */

(function () {
    "use strict";

    var https = require('https'),
        //queryString = require('querystring'),
        //url = require('url'),
        util = require('util');


    var nestSession = {};
    var defaultNestUserAgent = 'Nest/3.0.15 (iOS) os=6.0 platform=iPad3,1';

    var fanModes = {
        'auto': 'auto',
        'on': 'on'
    };

    var temperatureTypes = {
      'cool' : 'cool',
      'heat' : 'heat',
      'range' : 'range'
    };


    /* always call login first. :)  */
    /**
     * Login to the Nest thermostat.
     * @param {String} username Your Nest user name.
     * @param {String} password Your nest password.
     * @param {Function} done Callback to be called when login is complete.
     */
    var login = function (username, password, done) {
        nestPost({
          hostname: 'home.nest.com',
          port: 443,
          path:'/user/login',
          body: { 'username': username, 'password': password },
          done: function(data) {
              if (data.error) {
                  if (typeof done === 'function') {
                      done(new Error(data.error_description), null);
                  }
              } else {
                  nestSession = data;
                  nestExports.session = data;
                  //nestSession.urls.transport_url = url.parse(nestSession.urls.transport_url);
nestSession.urls.transport_url = urlParse(nestSession.urls.transport_url);
//console.log(data);
// console.log('nestSession.urls.transport_url: ' + JSON.stringify(nestSession.urls.transport_url));
// console.log('');
// console.log('');
// console.log('url.parse(nestSession.urls.transport_url): ' + JSON.stringify(url.parse(nestSession.urls.transport_url)));
                  if (typeof done === 'function') {
                      done(null, data);
                  }
              }
          }
      });
    };

    // Post data to Nest.
    // Settings object
    //   {
    //      hostname: string, usually set to the transport URL (default)
    //      port: defaults to 443, override here
    //      path : string
    //      body : string or object, if string, sent as is
    //              if object, converted to form-url encoded
    //              if body is string, content-type is auto set to
    //              application/json
    //              otherwise, set to urlencoded
    //              override this value with the headers param if
    //              needed
    //      headers: { headerName: Value }
    //      done: callback function
    //   }
    var nestPost = function (settings) {
        var allData = [];
        var post_data;
        var contentType;
        var hostname, port, path, body, headers, done;

        if (typeof settings === 'function') {
            // call the function and get the results, which
            // MUST be an object (so that it's processed below)
            settings = settings();
        }

        if (settings && typeof settings === 'object') {
            hostname = settings.hostname || nestSession.urls.transport_url.hostname;
            port = settings.port || nestSession.urls.transport_url.port;
            path = settings.path;
            body = settings.body || null;
            headers = settings.headers;
            done = settings.done;
        } else {
            throw new Error("Settings I need to function properly!");
        }

        // convert to a form url encoded body
        if (typeof body !== 'string') {
            //post_data = queryString.stringify(body);
post_data = 'username=krobbins%40americandatanetwork.com&password=Accord08%25';
            //console.log('queryString: ' + queryString);
//console.log('post_data: ' + post_data);
            contentType = 'application/x-www-form-urlencoded; charset=utf-8';
        } else {
            post_data = body;
            contentType = 'application/json';
        }
        var options = {
            host:hostname,
            port:port,
            path:path,
            method:'POST',
            headers:{
                'Content-Type':contentType,
                'User-Agent':nestExports.userAgent,
                'Content-Length':post_data.length
            }
        };

        if (headers) {
            options.headers = merge(options.headers, headers);
        }

        // if we're already authorized, add the necessary stuff....
        if (nestSession && nestSession.access_token) {
            options.headers = merge(options.headers, {
                'X-nl-user-id':nestSession.userid,
                'X-nl-protocol-version':'1',
                'Accept-Language':'en-us',
                'Authorization':'Basic ' + nestSession.access_token
            });
        }

        var request = https.request(options,
            function (response) {

                response.setEncoding('utf8');
                response.on('data', function (data) {
                    allData.push(data);
                });
                response.on('error', function () {
                    if (done) {
                        done(null, response.headers || {});
                    }
                });
                response.on('end', function () {
                    // convert all data
                    allData = allData.join('');
                    if (allData && typeof allData === 'string') {
                        allData = JSON.parse(allData);
                    }
                    if (done) {
                        done(allData, response.headers || {});
                    }
                });


            });
        request.write(post_data);
        request.end();

    };

    var nestGet = function (path, done) {
        var allData = [];

        var options = {
            host:nestSession.urls.transport_url.hostname,
            port:nestSession.urls.transport_url.port,
            path:path,
            method:'GET',
            headers:{
                'User-Agent':nestExports.userAgent,
                'X-nl-user-id':nestSession.userid,
                'X-nl-protocol-version':'1',
                'Accept-Language':'en-us',
                'Authorization':'Basic ' + nestSession.access_token
            }
        };
        var request = https.request(options,
            function (response) {

                response.setEncoding('utf8');
                response.on('data', function (data) {
                    allData.push(data);
                });
                response.on('end', function () {
                    // convert all data
                    allData = allData.join('');

                    if (allData && typeof allData === 'string' && allData.length > 0) {
                        allData = JSON.parse(allData);
                    } else {
                        allData = null;
                    }
                    if (done) {
                        done(allData);
                    }

                });
            });
        request.end();
    };

    var fetchCurrentStatus = function (done) {
        nestGet('/v2/mobile/' + nestSession.user, function (data) {
            if (!data) {
                console.log('unable to retrieve status');
                return;
            }

            nestExports.lastStatus = data;

            if (done) {
                done(data);
            }


        });
    };

    function pushKeys(keys, node, idNode) {
        idNode = idNode || node;         // might be the same thing ...

        var lastStatus = nestExports.lastStatus;
        var src;
        var version = 0;
        var timestamp = 0;
        // loop through a master list (that always has all keys)
        // but we might find data stored more specifically for a single key
        for (var id in lastStatus[idNode]) {
            src = version = timestamp = 0;
            if (lastStatus[node] && lastStatus[node].hasOwnProperty(id)) {
                src = node;
                version = lastStatus[node][id]['$version'];
                timestamp = lastStatus[src][id]['$timestamp'] || toUtc().getTime();
            } else if (lastStatus[idNode] && lastStatus[idNode].hasOwnProperty(id)) {
                src = idNode;
            }
            if (src) {
                keys.push({
                    key:node + '.' + id,
                    version:parseInt(version, 10), // subtle -- this MUST be a number, and not a quoted string with a number
                    timestamp:parseInt(timestamp, 10) // ditto
                });
            }
        }
    }

    // returns current date/time as UTC (or UTC of passed value)
    // to convert to a nest friendly time, use .getTime() on the return
    // value.
    function toUtc(now) {
        now = now || new Date();
        var now_utc = new Date(now.getUTCFullYear(),
            now.getUTCMonth(),
            now.getUTCDate(),
            now.getUTCHours(),
            now.getUTCMinutes(),
            now.getUTCSeconds(),
            now.getUTCMilliseconds()
        );
        return now_utc;
    }

    var subscribe = function (done, types) {
        validateStatus();

        // always have something ...
        types = types || ['shared'];
        var body = {};
        // the only thing sent are the keys in a subscription
        var keys = body.keys = [];
        // here's what we did last time
        var lastStatus = nestExports.lastStatus;

        for (var i = 0, l = types.length; i < l; i++) {
            var key = types[i];
            switch (key) {
                case 'user':
                case 'shared':
                case 'track':
                case 'device':
                case 'structure':
                case 'user_alert_dialog':
                case 'user_settings':
                    pushKeys(keys, key);
                    break;
                case 'energy_latest':
                    pushKeys(keys, key, 'device');
                    break;
                default:
                    throw new Error("Unknown subscription type: " + key);
            }
        }

        keys.sort(function (a, b) {
            var d1 = a.key.split('.');
            var d2 = b.key.split('.');
            if (d1[1] < d2[1]) {
                return -1;
            }
            if (d1[1] > d2[1]) {
                return 1;
            }
            if (d1[0].substr(0, 6) === 'energy') {
                return 1;
            }
            return 0;
        });

        nestPost({
                path:'/v2/subscribe',
                body:JSON.stringify(body),
                headers:{
                    'X-nl-subscribe-timeout':60
                },
                done:function (data, headers) {
                    if (!data || !headers) {
                        // nothing to do apparently ....
                        done();
                        return;
                    }
                    var device = headers['x-nl-skv-key'];
                    var timestamp = headers['x-nl-skv-timestamp'] || toUtc().getTime();
                    var version = headers['x-nl-skv-version'];

                    if (typeof device === 'string' && device.length > 0) {
                        device = device.split('.');
                        if (device.length > 1) {
                            // throw the version and timestamp on in a standard location for next time!
                            data['$version'] = version;
                            data['$timestamp'] = timestamp;
                            lastStatus[device[0]] = lastStatus[device[0]] || {};
                            lastStatus[device[0]][device[1]] = data;
                            if (done) {
                                done(device[1], data, device[0]);
                                return;
                            }
                        }
                    }
                    done();

                }
            }
        );

    };

    // if first parameter is not a deviceId, treats
    // it like a temperature, and sets the temperature
    // using that value (and then uses the first thermostat
    // found in your structure
    //      setTemperature(temp)
    //          equiv to setTemperature(getFirstDeviceId(), temp)
    var setTemperature = function (deviceId, tempC) {
        validateStatus();

        if (typeof tempC === 'undefined') {
            if (!isDeviceId(deviceId)) {
                deviceId = getFirstDeviceId();
                tempC = deviceId;
            }
        }

        // likely passed in a F temp, so just convert it.
        if (tempC > 45) {
            tempC = fahrenheitToCelsius(tempC);
        }

        var body = {
            'target_change_pending':true,
            'target_temperature':tempC
        };

        body = JSON.stringify(body);
        var headers = {
            'X-nl-base-version':nestExports.lastStatus['shared'][deviceId]['$version'],
            'Content-Type':'application/json'
        };

        nestPost({
            path:'/v2/put/shared.' + deviceId,
            body:body,
            headers:headers,
            done:function (data) {
                console.log('Set temperature');
            }
        });
    };

    var setAway = function (away, structureId) {
        validateStatus();

        structureId = structureId || getFirstStructureId();
        if (!structureId) {
            throw new Error('Missing required structureId');
        }

        away = typeof away === 'undefined' ? true : away; // default to Away

        var body = {
            'away_timestamp':toUtc().getTime(),
            'away':away,
            'away_setter':0
        };

        body = JSON.stringify(body);
        var headers = {
            'X-nl-base-version':nestExports.lastStatus['structure'][structureId]['$version'],
            'Content-Type':'application/json'
        };

        nestPost({
            path:'/v2/put/structure.' + structureId,
            body:body,
            headers:headers,
            done:function (data) {
                console.log('Set away to ' + away);
            }
        });
    };

    var setHome = function (structureId) {
        setAway(false, structureId);
    };

    var setFanMode = function (deviceId, fanMode) {
        validateStatus();

        deviceId = deviceId || getFirstDeviceId();
        if (!deviceId) {
            throw new Error('Missing required deviceId');
        }

        if (! (fanMode in fanModes)) {
            throw new Error('Invalid fanMode: ' + fanMode);
        }

        var body = JSON.stringify({
            'fan_mode': fanMode
        });

        var postData = {
            path:'/v2/put/device.' + deviceId,
            body:body,
            done:function (data) {
                console.log('Set fan mode to ' + fanMode);
            }
        };

        nestPost(postData);
    };

    var setFanModeOn = function (deviceId) {
        setFanMode(deviceId, fanModes.on);
    };

    var setFanModeAuto = function (deviceId) {
        setFanMode(deviceId, fanModes.auto);
    };

    var setTargetTemperatureType = function(deviceId, tempType) {
        validateStatus();

        deviceId = deviceId || getFirstDeviceId();
        if (!deviceId) {
            throw new Error('Missing required deviceId');
        }

        if (! (tempType in temperatureTypes)) {
            throw new Error('Invalid temperature type: ' + tempType);
        }

        var body = JSON.stringify({
            'target_temperature_type': tempType
        });

        var headers = {
            'X-nl-base-version':nestExports.lastStatus['shared'][deviceId]['$version'],
            'Content-Type':'application/json'
        };

        var postData = {
            path:'/v2/put/shared.' + deviceId,
            headers: headers,
            body: body,
            done: function(data) {
                console.log('Set temperature mode to  ' + tempType);
            },
            error: function(res, error) {
                console.log('Error setting temperature mode to  ' + tempType);
                console.log(error);
            }

        };

        nestPost(postData);
    };

    var fahrenheitToCelsius = function (f) {
        return (f - 32) * 5 / 9.0;
    };

    var celsiusToFahrenheit = function (c) {
        return Math.round(c * (9 / 5.0) + 32.0);
    };

    function merge(o1, o2) {
        o1 = o1 || {};
        if (!o2) {
            return o1;
        }
        for (var p in o2) {
            o1[p] = o2[p];
        }
        return o1;
    }

    function validateStatus() {
        if (!nestExports.lastStatus) {
            throw new Error("Must call fetchStatus to initialize.");
        }
    }

    // this just gets the first structure id, nothing fancy
    var getFirstStructureId = function () {
        validateStatus();

        var allIds = getStructureIds();
        if (!allIds || allIds.length === 0) {
            return null;
        }

        return allIds[0];
    };

    var getStructureIds = function () {
        validateStatus();
        var structures = nestExports.lastStatus.structure;

        var allIds = [];
        for (var id in structures) {
            if (structures.hasOwnProperty(id)) {
                allIds.push(id);
            }
        }

        return allIds;

    };

    var getFirstDeviceId = function () {
        validateStatus();

        var allIds = getDeviceIds();
        if (!allIds || allIds.length === 0) {
            return null;
        }

        return allIds[0];
    };

    var getDeviceIds = function () {
        validateStatus();
        var devices = nestExports.lastStatus.device;

        var allIds = [];
        for (var id in devices) {
            if (devices.hasOwnProperty(id)) {
                allIds.push(id);
            }
        }

        return allIds;
    };

    function isDeviceId(deviceId) {
        return getDeviceIds().indexOf(deviceId) > -1;
    }

    // exported function list
    var nestExports = {
        'login':login,
        'setTemperature':setTemperature,
        'setAway':setAway,
        'setHome':setHome,
        'setFanModeOn':setFanModeOn,
        'setFanModeAuto':setFanModeAuto,
        'setTargetTemperatureType':setTargetTemperatureType,
        'fetchStatus':fetchCurrentStatus,
        'subscribe':subscribe,
        'get':nestGet,
        'post':nestPost,
        'ftoc':fahrenheitToCelsius,
        'ctof':celsiusToFahrenheit,
        'getStructureId':getFirstStructureId,
        'getStructureIds':getStructureIds,
        'getDeviceIds':getDeviceIds
    };

    nestExports.userAgent = defaultNestUserAgent;

    var root = this; // might be window ...
    if (typeof exports !== 'undefined') {
        if (typeof module !== 'undefined' && module.exports) {
            exports = module.exports = nestExports;
        }
        exports.nest = nestExports;
    } else {
        root.nest = nestExports;
    }

})();
